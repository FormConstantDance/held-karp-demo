// Generated by CoffeeScript 1.4.0
(function() {
  var Engine, TEST_SUITE, assert, assertEqual, assertExt, assertFloatFBO, benchmark, benchmarkTrials, checkError, createCanvas, createFBO, createProgram, createShader, createTexture, determineTexSize, ensureCanvas, getCurrentTexBindings, getExt, getFBOType, getGPUInfo, getUniformLocation, getUniformSetter, getWebGL, lookupGLError, meanAndVariance, pixelTypeToArrayType, raise, runBenchmark, runTests, testBasic, testBitOn, testDefinedFunction, testExtraTex, testFullArity, testPingPong, testUniforms, testUploadArray, vertSrc;

  vertSrc = "attribute vec2 pos;\nvarying vec2 texcoord;\n\nvoid main() {\n    gl_Position = vec4(pos, 0, 1);\n    texcoord = (pos + vec2(1)) * vec2(0.5);\n}";

  getWebGL = function(canvas) {
    var experimental, gl;
    experimental = false;
    gl = null;
    try {
      gl = canvas[0].getContext("webgl");
    } catch (x) {
      gl = null;
    }
    if (gl === null) {
      try {
        gl = canvas[0].getContext("experimental-webgl");
      } catch (x) {
        gl = null;
      }
    }
    return gl;
  };

  getCurrentTexBindings = function(gl) {
    var i, map, maxTexUnits, tex, tu, _i;
    map = {};
    maxTexUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    for (i = _i = 0; 0 <= maxTexUnits ? _i < maxTexUnits : _i > maxTexUnits; i = 0 <= maxTexUnits ? ++_i : --_i) {
      tu = "TEXTURE" + i;
      gl.activeTexture(gl[tu]);
      tex = gl.getParameter(gl.TEXTURE_BINDING_2D);
      map[i] = tex;
    }
    return map;
  };

  getGPUInfo = function(gl) {
    var ext, info;
    info = {
      gpu: null,
      vendor: null
    };
    ext = getExt(gl, "WEBGL_debug_renderer_info");
    if (ext) {
      info.vendor = gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);
      info.gpu = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);
    }
    return info;
  };

  createCanvas = function(root, size, id) {
    var el, tag;
    tag = "<canvas id='" + id + "' width='" + size + "' height='" + size + "'></canvas>";
    el = $(tag);
    root.append(el);
    return el;
  };

  ensureCanvas = function(root, size, id) {
    var canvas;
    canvas = $("#" + id);
    if (!canvas.length) {
      canvas = createCanvas(root, size, id);
    }
    return canvas;
  };

  raise = function(msg) {
    console.log("ERROR: " + msg);
    throw msg;
  };

  assert = function(condition, message) {
    if (!condition) {
      return raise(message || "Assertion failed");
    }
  };

  assertEqual = function(a, b) {
    return assert(_.isEqual(a, b), "" + a + " not equal to " + b);
  };

  lookupGLError = function(gl, err) {
    var key, val;
    for (key in gl) {
      val = gl[key];
      if (err === val) {
        return key;
      }
    }
  };

  checkError = function(gl) {
    var err, glEnum;
    err = gl.getError();
    if (err !== gl.NO_ERROR) {
      glEnum = lookupGLError(gl, err);
      return raise("GL error: " + glEnum);
    }
  };

  getUniformLocation = function(gl, program, name) {
    var pos;
    pos = gl.getUniformLocation(program, name);
    checkError(gl);
    assert(pos !== null, "" + name + " not found");
    return pos;
  };

  getExt = function(gl, name) {
    return gl.getExtension(name);
  };

  assertExt = function(gl, name) {
    var ext;
    ext = getExt(gl, name);
    assert(ext, "" + name + " extension required but not found.");
    return ext;
  };

  createShader = function(gl, src, type) {
    var log, shader, status;
    shader = gl.createShader(type);
    checkError(gl);
    gl.shaderSource(shader, src);
    checkError(gl);
    gl.compileShader(shader, src);
    checkError(gl);
    status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    checkError(gl);
    if (!status) {
      log = gl.getShaderInfoLog(shader);
      checkError(gl);
      throw log;
    }
    return shader;
  };

  createProgram = function(gl, vs, fs) {
    var prog;
    prog = gl.createProgram();
    checkError(gl);
    gl.attachShader(prog, vs);
    checkError(gl);
    gl.attachShader(prog, fs);
    checkError(gl);
    gl.linkProgram(prog);
    checkError(gl);
    return prog;
  };

  createTexture = function(gl, width, height) {
    var tex;
    tex = gl.createTexture();
    checkError(gl);
    tex.width = width;
    tex.height = height;
    gl.bindTexture(gl.TEXTURE_2D, tex);
    checkError(gl);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    checkError(gl);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    checkError(gl);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    checkError(gl);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    checkError(gl);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, null);
    checkError(gl);
    gl.bindTexture(gl.TEXTURE_2D, null);
    return tex;
  };

  pixelTypeToArrayType = function(gl, pixelType) {
    var m;
    m = {};
    m[gl.FLOAT] = Float32Array;
    m[gl.UNSIGNED_BYTE] = Uint8Array;
    return m[pixelType];
  };

  createFBO = function(gl, tex) {
    var fbo;
    fbo = gl.createFramebuffer();
    checkError(gl);
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    checkError(gl);
    fbo.width = tex.width;
    fbo.height = tex.height;
    fbo.tex = tex;
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    checkError(gl);
    assert(gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    checkError(gl);
    return fbo;
  };

  determineTexSize = function(numElements, maxSize) {
    var numCols, numPixels, numRows;
    numPixels = Math.ceil(numElements / 4);
    numCols = Math.min(maxSize, numPixels);
    numRows = Math.ceil(numPixels / maxSize);
    return [numCols, numRows];
  };

  getUniformSetter = function(gl, type, val) {
    var name, setter;
    name = "uniform" + type;
    setter = gl[name];
    assert(!_.isUndefined(setter, name));
    return setter;
  };

  getFBOType = function(gl, fbo) {
    var fboType;
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    checkError(gl);
    fboType = gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    checkError(gl);
    return fboType;
  };

  assertFloatFBO = function(gl) {
    var fbo, tex, type;
    tex = createTexture(gl, 100, 100);
    try {
      fbo = createFBO(gl, tex);
    } catch (error) {
      throw "Writing (using FBO) float textures unsupported.\nIf using Safari, try Chrome or Firefox on desktop.";
    }
    type = getFBOType(gl, fbo);
    return assert(type === gl.FLOAT, "Reading (readPixels) float textures unsupported.\nIf using Safari, try Chrome or Firefox on desktop.");
  };

  this.Storage = (function() {

    Storage.fromImage = function(engine, img, pixelType) {
      var gl, storage, tex;
      gl = engine.gl;
      pixelType = gl[pixelType];
      tex = createTexture(gl, img.width, img.height);
      gl.bindTexture(gl.TEXTURE_2D, tex);
      checkError(gl);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, pixelType, img);
      checkError(gl);
      gl.bindTexture(gl.TEXTURE_2D, null);
      storage = new Storage(engine, tex, pixelType);
      return storage;
    };

    Storage.fromData = function(engine, data) {
      var gl, size, storage;
      gl = engine.gl;
      size = data.length;
      storage = this.fromSize(engine, size);
      storage.upload(data);
      return storage;
    };

    Storage.fromSize = function(engine, size, data) {
      var gl, height, storage, tex, width, _ref;
      if (data == null) {
        data = null;
      }
      gl = engine.gl;
      if (size instanceof Array) {
        width = size[0], height = size[1];
      } else {
        _ref = determineTexSize(size, engine.maxSize), width = _ref[0], height = _ref[1];
      }
      tex = createTexture(gl, width, height);
      storage = new Storage(engine, tex, gl.FLOAT);
      if (data) {
        storage.upload(data);
      }
      return storage;
    };

    function Storage(engine, tex, dataType) {
      this.engine = engine;
      this.tex = tex;
      this.dataType = dataType;
      this.gl = this.engine.gl;
      this.padding = 0;
      this.width = tex.width;
      this.height = tex.height;
      this.helperFBO = createFBO(this.gl, this.tex);
    }

    Storage.prototype.upload = function(array) {
      var goodSize, maxSize, numPixels, paddedArray;
      if (array.length % 4 !== 0) {
        goodSize = Math.ceil(array.length / 4) * 4;
        this.padding = goodSize - array.length;
        paddedArray = new Float32Array(goodSize);
        paddedArray.set(array);
        array = paddedArray;
      }
      maxSize = this.engine.maxSize;
      numPixels = array.length / 4;
      if (numPixels > maxSize && numPixels % maxSize !== 0) {
        goodSize = Math.ceil(numPixels / maxSize) * maxSize * 4;
        this.padding = this.padding + goodSize - array.length;
        paddedArray = new Float32Array(goodSize);
        paddedArray.set(array);
        array = paddedArray;
      }
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.tex);
      checkError(this.gl);
      this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.width, this.height, 0, this.gl.RGBA, this.gl.FLOAT, array);
      checkError(this.gl);
      return this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    };

    Storage.prototype.download = function(padding) {
      var array, arrayType;
      if (padding == null) {
        padding = this.padding;
      }
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.helperFBO);
      checkError(this.gl);
      arrayType = pixelTypeToArrayType(this.gl, this.dataType);
      array = new arrayType(this.width * this.height * 4);
      this.gl.readPixels(0, 0, this.width, this.height, this.gl.RGBA, this.dataType, array);
      checkError(this.gl);
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
      checkError(this.gl);
      if (padding) {
        array = array.subarray(0, array.length - padding);
      }
      return array;
    };

    return Storage;

  })();

  this.Computation = (function() {

    function Computation(engine, size, text, preamble, arity) {
      var arityFullText, arityOneText, fragShader, fragSrc, preambleText;
      this.engine = engine;
      this.size = size;
      this.text = text;
      this.preamble = preamble != null ? preamble : null;
      this.arity = arity != null ? arity : 1;
      this.gl = this.engine.gl;
      if (this.arity === 1) {
        arityFullText = "";
        arityOneText = this.text;
      } else {
        arityFullText = this.text;
        arityOneText = "";
      }
      if (this.preamble === null) {
        preambleText = "";
      } else {
        preambleText = this.preamble;
      }
      fragSrc = "precision highp float;\nprecision highp int;\nvarying vec2 texcoord;\n\nuniform sampler2D tex_inputs;\nuniform ivec2 input_size;\nuniform int arity;\n\n" + preambleText + "\n\nvoid execute(in float src, out float dst, in int execute_idx, in int offset_idx) {\n    " + arityOneText + "\n}\n\nvoid execute(in vec4 src, out vec4 dst, in int execute_idx, in int offset_idx) {\n    " + arityFullText + "\n}\n\nvoid main() {\n    vec4 inputs = texture2D(tex_inputs, texcoord);\n    vec4 outputs;\n    int kernel_offset = int(gl_FragCoord.x) + int(gl_FragCoord.y) * input_size.x;\n\n    if (arity == 1) {\n        execute(inputs[0], outputs[0], kernel_offset, 0);\n        execute(inputs[1], outputs[1], kernel_offset, 1);\n        execute(inputs[2], outputs[2], kernel_offset, 2);\n        execute(inputs[3], outputs[3], kernel_offset, 3);\n    }\n    // arity is 4 or \"full\"\n    else {\n        execute(inputs, outputs, kernel_offset, 0);\n    }\n\n    gl_FragColor = outputs;\n}";
      fragShader = createShader(this.gl, fragSrc, this.gl.FRAGMENT_SHADER);
      this.program = createProgram(this.gl, this.engine.vertShader, fragShader);
    }

    Computation.prototype.execute = function(inputs, uniforms, output) {
      var results;
      if (output == null) {
        output = null;
      }
      output = this.step(inputs, uniforms, output);
      results = output.download();
      return results;
    };

    Computation.prototype.step = function(inputs, uniforms, output) {
      var arityPos, availTextureUnits, bindTexture, boundTextures, getTexUnit, i, name, outFBO, pos, setter, tex, type, val, _ref,
        _this = this;
      if (output == null) {
        output = null;
      }
      assert(inputs instanceof Storage, "inputs are not Storage");
      if (!output) {
        output = Storage.fromSize(this.engine, this.size);
      }
      outFBO = createFBO(this.gl, output.tex);
      output.padding = inputs.padding;
      this.gl.useProgram(this.program);
      checkError(this.gl);
      availTextureUnits = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = _ref = this.engine.maxTexUnits - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
          _results.push(i);
        }
        return _results;
      }).call(this);
      boundTextures = [];
      getTexUnit = function() {
        var name, tu;
        tu = availTextureUnits.pop();
        name = "TEXTURE" + tu;
        return [tu, _this.gl[name]];
      };
      bindTexture = function(tex, name) {
        var pos, tu, tuEnum, unbind, _ref;
        assert(!_.isUndefined(tex), "tex for " + name + " is undefined");
        _ref = getTexUnit(), tu = _ref[0], tuEnum = _ref[1];
        _this.gl.activeTexture(tuEnum);
        checkError(_this.gl);
        _this.gl.bindTexture(_this.gl.TEXTURE_2D, tex);
        checkError(_this.gl);
        unbind = function() {
          _this.gl.activeTexture(tuEnum);
          checkError(_this.gl);
          _this.gl.bindTexture(_this.gl.TEXTURE_2D, null);
          return checkError(_this.gl);
        };
        boundTextures.push(unbind);
        pos = getUniformLocation(_this.gl, _this.program, name);
        _this.gl.uniform1i(pos, tu);
        return checkError(_this.gl);
      };
      bindTexture(inputs.tex, "tex_inputs");
      arityPos = getUniformLocation(this.gl, this.program, "arity");
      this.gl.uniform1i(arityPos, this.arity);
      checkError(this.gl);
      pos = this.gl.getUniformLocation(this.program, "input_size");
      checkError(this.gl);
      if (pos !== null) {
        this.gl.uniform2i(pos, inputs.tex.width, inputs.tex.height);
        checkError(this.gl);
      }
      this.gl.viewport(0, 0, output.tex.width, output.tex.height);
      checkError(this.gl);
      for (name in uniforms) {
        _ref = uniforms[name], type = _ref[0], val = _ref[1];
        pos = getUniformLocation(this.gl, this.program, name);
        if (type === "s") {
          tex = val.tex || val;
          bindTexture(tex, name);
        } else {
          setter = getUniformSetter(this.gl, type, val);
          setter.call(this.gl, pos, val);
          checkError(this.gl);
        }
      }
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, outFBO);
      checkError(this.gl);
      this.engine.draw(this.program);
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
      return output;
    };

    return Computation;

  })();

  Engine = (function() {

    function Engine(root) {
      var maxTexSize, maxViewport, plane;
      this.root = root;
      this.canvas = ensureCanvas(this.root, 1, "gpgpu-canvas");
      this.gl = getWebGL(this.canvas);
      assert(this.gl !== null, "WebGL not enabled.");
      this.gpuInfo = getGPUInfo(this.gl);
      maxTexSize = this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE);
      checkError(this.gl);
      maxViewport = this.gl.getParameter(this.gl.MAX_VIEWPORT_DIMS)[0];
      checkError(this.gl);
      this.maxSize = Math.min(maxTexSize, maxViewport);
      this.maxTexUnits = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);
      assertExt(this.gl, "OES_texture_float");
      assertFloatFBO(this.gl);
      this.vertShader = createShader(this.gl, vertSrc, this.gl.VERTEX_SHADER);
      this.buffer = this.gl.createBuffer();
      checkError(this.gl);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
      checkError(this.gl);
      plane = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, plane, this.gl.STATIC_DRAW);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
      checkError(this.gl);
    }

    Engine.prototype.draw = function(program) {
      var pos;
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
      checkError(this.gl);
      pos = this.gl.getAttribLocation(program, "pos");
      checkError(this.gl);
      this.gl.enableVertexAttribArray(pos);
      checkError(this.gl);
      this.gl.vertexAttribPointer(pos, 2, this.gl.FLOAT, false, 0, 0);
      checkError(this.gl);
      this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
      return checkError(this.gl);
    };

    Engine.prototype.execute = function(inputData, kernel, preamble, arity) {
      var comp, inputs;
      if (preamble == null) {
        preamble = null;
      }
      if (arity == null) {
        arity = 1;
      }
      inputs = Storage.fromData(this, inputData);
      comp = this.createComputation(inputData.length, kernel, preamble, arity);
      return comp.execute(inputs);
    };

    Engine.prototype.createComputation = function(size, kernel, preamble, arity) {
      if (preamble == null) {
        preamble = null;
      }
      if (arity == null) {
        arity = 1;
      }
      return new Computation(this, size, kernel, preamble, arity);
    };

    return Engine;

  })();

  this.getEngine = function(root) {
    return new Engine(root);
  };

  testBasic = function(engine) {
    var inputs, outputs;
    inputs = new Float32Array([1, 2, 3, 4, 5]);
    outputs = engine.execute(inputs, "dst = src * src;");
    return assertEqual(outputs, new Float32Array([1, 4, 9, 16, 25]));
  };

  testPingPong = function(engine) {
    var comp, inputData, inputs, outputs;
    inputData = new Float32Array([1, 2, 3, 4, 5]);
    inputs = Storage.fromData(engine, inputData);
    comp = engine.createComputation(inputData.length, "dst = src * src;");
    inputs = comp.step(inputs);
    inputs = comp.step(inputs);
    inputs = comp.step(inputs);
    outputs = inputs.download();
    return assertEqual(outputs, new Float32Array([1, 256, 6561, 65536, 390625]));
  };

  testUploadArray = function(engine) {
    var comp, inputData, inputs, kernel, numsSize, outputs, preamble;
    inputData = new Float32Array([1, 2, 3, 4, 5]);
    inputs = Storage.fromData(engine, inputData);
    numsSize = 2;
    preamble = "uniform int nums[" + numsSize + "];\n\nint lookup(in int nums[" + numsSize + "], in int idx) {\n    for (int i=0; i<" + numsSize + "; i++) {\n        if (i==idx) {\n            return nums[i];\n        }\n    }\n}";
    kernel = "dst = src * float(lookup(nums, execute_idx));";
    comp = engine.createComputation(inputData.length, kernel, preamble);
    outputs = comp.execute(inputs, {
      nums: ["1iv", new Int32Array([2, 3])]
    });
    return assertEqual(outputs, new Float32Array([2, 4, 6, 8, 15]));
  };

  testUniforms = function(engine) {
    var comp, inputData, inputs, outputs;
    inputData = new Float32Array([1, 2, 3, 4, 5]);
    inputs = Storage.fromData(engine, inputData);
    comp = engine.createComputation(inputData.length, "dst = src * float(num);", "uniform int num;");
    outputs = comp.execute(inputs, {
      num: ["1i", 3]
    });
    return assertEqual(outputs, new Float32Array([3, 6, 9, 12, 15]));
  };

  testDefinedFunction = function(engine) {
    var inputs, outputs, preamble;
    inputs = new Float32Array([1, 2, 3, 4, 5]);
    preamble = "float cube(float v) {\n    return v * v * v;\n}";
    outputs = engine.execute(inputs, "dst = cube(src);", preamble);
    return assertEqual(outputs, new Float32Array([1, 8, 27, 64, 125]));
  };

  testFullArity = function(engine) {
    var inputs, outputs;
    inputs = new Float32Array([1, 2, 3, 4]);
    outputs = engine.execute(inputs, "dst[0] = dot(src, vec4(1.0));", "", 4);
    return assertEqual(outputs, new Float32Array([10, 0, 0, 0]));
  };

  testBitOn = function(engine) {
    var comp, inputData, inputs, kernel, outputs, preamble;
    preamble = "uniform int check;\n\nbool bit_on(int num, int bit_idx, out int bit_off) {\n    int shift = int(pow(2.0, float(bit_idx)));\n    int tmp = num / shift;\n    bool bit_on = int(mod(float(tmp), 2.0)) != 0;\n\n    bit_off = num;\n    if (bit_on) {\n        bit_off = num - int(pow(2.0, float(bit_idx)));\n    }\n    return bit_on;\n}";
    inputData = new Float32Array([1 << 0, 1 << 1, 6]);
    inputs = Storage.fromData(engine, inputData);
    kernel = "int off = 0;\nbool was_on = bit_on(int(src), check, off);\ndst = float(off) + (was_on ? 1.0 : 0.0);";
    comp = engine.createComputation(inputData.length, kernel, preamble);
    outputs = comp.execute(inputs, {
      check: ["1i", 1]
    });
    assertEqual(outputs, new Float32Array([1, 1, 5]));
    inputData = new Float32Array([1 << 7, 1 << 6, 1 << 5]);
    inputs = Storage.fromData(engine, inputData);
    outputs = comp.execute(inputs, {
      check: ["1i", 7]
    });
    assertEqual(outputs, new Float32Array([1, 64, 32]));
    inputData = new Float32Array([1 << 15, 1 << 13, 1 << 14]);
    inputs = Storage.fromData(engine, inputData);
    outputs = comp.execute(inputs, {
      check: ["1i", 14]
    });
    return assertEqual(outputs, new Float32Array([32768, 8192, 1]));
  };

  testExtraTex = function(engine) {
    var comp, inputData, inputs, kernel, outputs, preamble, uniforms, util, utilData;
    preamble = "uniform sampler2D util;\n\nfloat lookup(in vec4 vals, in int idx) {\n    for (int i=0; i<4; i++) {\n        if (i==idx) {\n            return vals[i];\n        }\n    }\n}";
    kernel = "vec4 vals = texture2D(util, texcoord);\nfloat val = lookup(vals, offset_idx);\ndst = src * val;";
    inputData = new Float32Array([1, 2, 3, 4, 5]);
    inputs = Storage.fromData(engine, inputData);
    utilData = new Float32Array([6, 7, 8, 20, 15]);
    util = Storage.fromData(engine, utilData);
    comp = engine.createComputation(inputData.length, kernel, preamble);
    uniforms = {
      "util": ["s", util]
    };
    outputs = comp.execute(inputs, uniforms);
    return assertEqual(outputs, new Float32Array([6, 14, 24, 80, 75]));
  };

  TEST_SUITE = [["basic", testBasic], ["pingPong", testPingPong], ["uploadArray", testUploadArray], ["extraTex", testExtraTex], ["definedFunction", testDefinedFunction], ["fullArity", testFullArity], ["uniforms", testUniforms], ["bitOn", testBitOn]];

  benchmark = function(engine, num, kernelCPU, kernelGPU) {
    var comp, dataCorrect, e, elapsedCPU, elapsedGPU, end, i, inputData, inputs, overheadGPUElapsed, results, resultsCPU, resultsGPU, start, _, _i, _j, _k, _len, _len1, _ref;
    inputs = new Float32Array(num);
    for (i = _i = 0, _ref = inputs.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      inputs[i] = Math.random();
    }
    resultsCPU = new Float32Array(inputs.length);
    start = performance.now();
    for (i = _j = 0, _len = inputs.length; _j < _len; i = ++_j) {
      num = inputs[i];
      resultsCPU[i] = kernelCPU(num);
    }
    elapsedCPU = performance.now() - start;
    start = performance.now();
    inputData = Storage.fromData(engine, inputs);
    comp = engine.createComputation(inputs.length, kernelGPU);
    overheadGPUElapsed = performance.now() - start;
    start = performance.now();
    results = comp.step(inputData);
    engine.gl.finish();
    end = performance.now();
    elapsedGPU = end - start;
    start = performance.now();
    resultsGPU = results.download();
    overheadGPUElapsed += performance.now() - start;
    e = 0.00001;
    for (i = _k = 0, _len1 = resultsCPU.length; _k < _len1; i = ++_k) {
      _ = resultsCPU[i];
      dataCorrect = Math.abs(resultsCPU[i] - resultsGPU[i]) < e;
      if (!dataCorrect) {
        break;
      }
    }
    assert(dataCorrect, "results did not match");
    assert(resultsCPU.length === resultsGPU.length, "result sizes differ " + resultsCPU.length + " vs " + resultsGPU.length);
    return [elapsedCPU, elapsedGPU, overheadGPUElapsed];
  };

  meanAndVariance = function(samples) {
    var mean;
    samples = _.clone(samples);
    samples.sort();
    samples.pop();
    samples.shift();
    mean = _.mean(samples);
    return [mean, 0];
  };

  benchmarkTrials = function(trials, engine, num, kernelCPU, kernelGPU) {
    var elapsedCPU, elapsedCPUSamples, elapsedGPU, elapsedGPUOverheadSamples, elapsedGPUSamples, i, meanCPU, meanGPU, meanGPUOverhead, overheadGPUElapsed, results, varCPU, varGPU, varGPUOverhead, _i, _ref, _ref1, _ref2;
    elapsedCPUSamples = [];
    elapsedGPUSamples = [];
    elapsedGPUOverheadSamples = [];
    for (i = _i = 1; 1 <= trials ? _i <= trials : _i >= trials; i = 1 <= trials ? ++_i : --_i) {
      results = benchmark(engine, num, kernelCPU, kernelGPU);
      elapsedCPU = results[0], elapsedGPU = results[1], overheadGPUElapsed = results[2];
      elapsedCPUSamples.push(elapsedCPU);
      elapsedGPUSamples.push(elapsedGPU);
      elapsedGPUOverheadSamples.push(overheadGPUElapsed);
    }
    _ref = meanAndVariance(elapsedCPUSamples), meanCPU = _ref[0], varCPU = _ref[1];
    _ref1 = meanAndVariance(elapsedGPUSamples), meanGPU = _ref1[0], varGPU = _ref1[1];
    _ref2 = meanAndVariance(elapsedGPUOverheadSamples), meanGPUOverhead = _ref2[0], varGPUOverhead = _ref2[1];
    return [[meanCPU, varCPU], [meanGPU, varGPU], [meanGPUOverhead, varGPUOverhead]];
  };

  runBenchmark = function(samples) {
    var elapsedCPU, elapsedGPU, elapsedGPUOverhead, engine, gpuTotal, kernelCPU, kernelGPU, root, speedup, tSpeedup, _ref;
    root = $("#gpgpu");
    engine = getEngine(root);
    kernelCPU = function(num) {
      return num + Math.tan(Math.cos(Math.sin(num * num)));
    };
    kernelGPU = "dst = src + tan(cos(sin(src * src)));";
    _ref = benchmarkTrials(10, engine, samples, kernelCPU, kernelGPU), elapsedCPU = _ref[0], elapsedGPU = _ref[1], elapsedGPUOverhead = _ref[2];
    gpuTotal = elapsedGPU[0] + elapsedGPUOverhead[0];
    speedup = elapsedCPU[0] / gpuTotal;
    tSpeedup = elapsedCPU[0] / elapsedGPU[0];
    console.log("CPU:", elapsedCPU[0]);
    console.log("GPU Total:", gpuTotal);
    console.log("GPU Execution:", elapsedGPU[0]);
    console.log("GPU IO:", elapsedGPUOverhead[0]);
    console.log("Actual Speedup:", speedup);
    return console.log("Theoretical Speedup:", tSpeedup);
  };

  runTests = function() {
    var engine, name, root, test, _i, _len, _ref, _results;
    root = $("#gpgpu");
    _results = [];
    for (_i = 0, _len = TEST_SUITE.length; _i < _len; _i++) {
      _ref = TEST_SUITE[_i], name = _ref[0], test = _ref[1];
      console.log("running " + name);
      engine = getEngine(root);
      _results.push(test(engine));
    }
    return _results;
  };

}).call(this);
