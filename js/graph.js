// Generated by CoffeeScript 1.4.0
(function() {
  var DEFAULT_NUM_NODES, MAX_NODES, MAX_PERFORMANCE_POINTS, MIN_NODES, NODE_PADDING, TOUR_COLOR, addNode, async, backtrackParents, benchmark, buildCPUSolver, buildGPUSolver, chart, chartDef, chartPromise, clearGraph, colorizeTSP, constructComputationKernels, costMatrixFromNodes, cpuSolver, drawChart, edgesFromPath, engine, extractNodesForAugment, extractNodesForSolver, failGPU, getCost, getNumNodes, getSolver, getSolverType, gpuSolver, graphNodes, graphToNorm, hashPixel, loadImage, loadSubpathLevels, normToGraph, now, packPixel, parsePixels, recomputeTSP, refreshNodes, removeNode, resetGraph, root, textureLookupCost, toggleSymmetric, unpackImage, unpackImageData, updateCost, updateGraph, updateUICost, updateUITime,
    __slice = [].slice;

  TOUR_COLOR = "green";

  NODE_PADDING = [100, 20];

  MAX_NODES = 16;

  DEFAULT_NUM_NODES = 13;

  MIN_NODES = 3;

  MAX_PERFORMANCE_POINTS = 10;

  if (!_.isUndefined(performance)) {
    now = function() {
      return performance.now();
    };
  } else {
    now = function() {
      return Date.now();
    };
  }

  chart = null;

  chartDef = $.Deferred();

  chartPromise = chartDef.promise();

  constructComputationKernels = function(numNodes) {
    var kernel, preamble;
    preamble = "uniform sampler2D level_tex;\nuniform sampler2D subpath_tex;\nuniform vec2 level_tex_size;\nuniform float cost_matrix[256];\nuniform int num_nodes;\nuniform int cur_level;\n\n/*\n * performs our cost matrix lookup, from node a to node b\n */\nfloat cost_between(int a, int b) {\n    int idx = num_nodes * a + b;\n    float cost = 0.0;\n\n    // the uglist array lookup in the world\n    for (int i=0; i<256; i++) {\n        if (i == idx) {\n            cost = cost_matrix[i];\n            break;\n        }\n    }\n    return cost;\n}\n\n/*\n * takes a num and a 0-based bit_idx and returns if the bit was on\n * at that index.  if it was on, flip it off, and set the resulting\n * value to bit_off\n */\nbool bit_on(int num, int bit_idx, out int bit_off) {\n    int shift = int(pow(2.0, float(bit_idx)));\n    int tmp = num / shift;\n    bool bit_on = int(mod(float(tmp), 2.0)) != 0;\n\n    bit_off = num;\n    if (bit_on) {\n        bit_off = num - int(pow(2.0, float(bit_idx)));\n    }\n    return bit_on;\n}\n\n/*\n * takes a pixel's worth of subpath level query data and hashes\n * it to an index\n */\nint hash_pixel(in ivec3 pixel) {\n    int idx = pixel.r*65536 + pixel.g*256 + pixel.b;\n    return idx;\n}";
    kernel = "/*\n * assignment to src (which will be 0) initially prevents the gpu compiler from\n * optimizing away src, and related, tex_inputs\n */\nfloat min_cost = src.r;\nint parent;\n\nvec4 level_data = texture2D(level_tex, texcoord);\nint checking_level = 255-int(level_data.a*255.0);\nint end_at = int(level_data.r*255.0);\n\nint go_through = int(level_data.g*255.0);\nint go_through2 = int(level_data.b*255.0);\nint cur_go_through = go_through;\n\nconst int num_nodes_real = " + numNodes + ";\n\n\n/*\n * since our shader runs on every subpath query on every level, simultaneously,\n * we need a way to short-circuit queries that it's not time to solve yet.\n */\nif (checking_level != cur_level) {\n    discard;\n    return;\n}\n\nif (cur_level == 0) {\n    min_cost = cost_between(0, end_at);\n    parent = 0;\n}\nelse {\n    for (int check_parent=0; check_parent<num_nodes_real; check_parent++) {\n\n        bool second_byte = check_parent >= 8;\n\n        int check_adjusted = check_parent;\n        if (second_byte) {\n            cur_go_through = go_through2;\n            check_adjusted -= 8;\n        }\n\n        int bit_off;\n        bool was_on = bit_on(cur_go_through, check_adjusted, bit_off);\n\n        if (was_on) {\n            int subpath_idx;\n            ivec3 pixel;\n            pixel.r = check_parent;\n\n            if (second_byte) {\n                pixel.g = go_through;\n                pixel.b = bit_off;\n            }\n            else {\n                pixel.g = bit_off;\n                pixel.b = go_through2;\n            }\n\n            subpath_idx = hash_pixel(pixel);\n\n            vec2 subpath_texcoord;\n            subpath_texcoord.x = mod(float(subpath_idx), level_tex_size.x) / level_tex_size.x;\n            subpath_texcoord.y = (float(subpath_idx) / level_tex_size.x) / level_tex_size.y;\n\n            vec4 subpath = texture2D(subpath_tex, subpath_texcoord);\n            float cost = subpath.x + cost_between(check_parent, end_at);\n            if (cost < min_cost) {\n                min_cost = cost;\n                parent = check_parent;\n            }\n\n        }\n    }\n\n}\n\n\ndst.x = min_cost;\ndst.y = float(parent);\ndst.z = float(cur_level);\ndst.w = float(cur_go_through);";
    return [preamble, kernel];
  };

  benchmark = function(fn) {
    var start;
    start = now();
    fn();
    return now() - start;
  };

  toggleSymmetric = function(cy, symmetric) {
    var curveStyle, opacity, style;
    curveStyle = "bezier";
    opacity = 0.1;
    if (symmetric) {
      curveStyle = "haystack";
      opacity *= 0.5;
    }
    style = cy.style();
    style.selector("edge.route").style({
      "curve-style": curveStyle,
      opacity: opacity
    }).update();
    return cy.style().selector("edge.tour").style({
      "curve-style": "haystack",
      opacity: 1
    }).update();
  };

  normToGraph = function(cy, val) {
    var graphHeight, graphWidth, newHeight, newWidth;
    graphWidth = cy.width();
    graphHeight = cy.height();
    newWidth = val[0] * (graphWidth - NODE_PADDING[0] * 2) + NODE_PADDING[0];
    newHeight = val[1] * (graphHeight - NODE_PADDING[1] * 2) + NODE_PADDING[1];
    return [newWidth, newHeight];
  };

  graphToNorm = function(cy, val) {
    var graphHeight, graphWidth, newHeight, newWidth;
    graphWidth = cy.width();
    graphHeight = cy.height();
    newWidth = (val[0] - NODE_PADDING[0]) / (graphWidth - NODE_PADDING[0] * 2);
    newHeight = (val[1] - NODE_PADDING[1]) / (graphHeight - NODE_PADDING[1] * 2);
    return [newWidth, newHeight];
  };

  graphNodes = function(cy, solver, nodes, symmetric) {
    var cost, get, i, id, newPos, node, pos, src, srcPos, target, targetPos;
    if (symmetric == null) {
      symmetric = true;
    }
    toggleSymmetric(cy, symmetric);
    for (i in nodes) {
      node = nodes[i];
      pos = node.pos;
      newPos = normToGraph(cy, [pos.x, pos.y]);
      cy.add({
        data: {
          id: node.id
        },
        selectable: false,
        position: {
          x: newPos[0],
          y: newPos[1]
        }
      });
    }
    get = function(id) {
      return cy.$("#" + id);
    };
    for (src in nodes) {
      node = nodes[src];
      for (target in node.edges) {
        if (src === target) {
          continue;
        }
        id = "" + src + "-" + target;
        srcPos = get(src).position();
        targetPos = get(target).position();
        cost = distance(srcPos, targetPos);
        cy.add({
          data: {
            id: id,
            cost: cost,
            source: src,
            target: target
          },
          classes: "route",
          selectable: false
        });
      }
    }
    return recomputeTSP(cy, solver);
  };

  getNumNodes = function(cy) {
    return cy.nodes().length;
  };

  extractNodesForAugment = function(cy) {
    var nodes;
    nodes = {};
    cy.nodes().forEach(function(cyNode) {
      var id, newPos, node;
      id = cyNode.id();
      newPos = graphToNorm(cy, [cyNode.position("x"), cyNode.position("y")]);
      node = {
        id: parseInt(id),
        pos: {
          x: newPos[0],
          y: newPos[1]
        }
      };
      return nodes[id] = node;
    });
    computeEdges(nodes);
    return nodes;
  };

  extractNodesForSolver = function(cy) {
    var nodes;
    nodes = {};
    cy.edges().forEach(function(edge) {
      var cost, src, target, targets;
      src = edge.source().data("id");
      target = edge.target().data("id");
      cost = edge.data("cost");
      targets = nodes[src];
      if (_.isUndefined(targets)) {
        targets = {};
        nodes[src] = targets;
      }
      return targets[target] = cost;
    });
    return nodes;
  };

  edgesFromPath = function(path, fn) {
    var i, indices, src, target, _i, _j, _len, _ref, _ref1, _results, _results1;
    indices = (function() {
      _results = [];
      for (var _i = 0, _ref = path.length; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    _ref1 = _.slice(indices, 0, indices.length - 2);
    _results1 = [];
    for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
      i = _ref1[_j];
      src = path[i];
      target = path[i + 1];
      _results1.push(fn(src, target));
    }
    return _results1;
  };

  colorizeTSP = function(cy, path) {
    cy.edges().removeClass("tour");
    return edgesFromPath(path, function(src, target) {
      var edge, edgeId, node;
      edgeId = "" + src + "-" + target;
      edge = cy.$("#" + edgeId);
      edge.addClass("tour");
      node = cy.getElementById(src);
      return node.addClass("tour");
    });
  };

  async = function(fn) {
    var def;
    def = $.Deferred();
    _.defer(function() {
      return def.resolve(fn());
    });
    return def.promise();
  };

  getCost = function(nodes, path) {
    var cost, idx, lastIdx, _i, _len, _ref;
    cost = 0;
    lastIdx = path[0];
    _ref = _.slice(path, 1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      idx = _ref[_i];
      cost += nodes[lastIdx][idx];
      lastIdx = idx;
    }
    return cost;
  };

  recomputeTSP = function(cy, solver) {
    var nodes, pathPromise;
    nodes = extractNodesForSolver(cy);
    pathPromise = solver(nodes);
    return pathPromise.then(function(data) {
      var cost, elapsed, path;
      path = data[0], elapsed = data[1];
      cost = getCost(nodes, path);
      updateUICost(cost, nodes, solver);
      updateUITime(elapsed, nodes, solver);
      return colorizeTSP(cy, path);
    });
  };

  updateCost = function(ev) {
    var cy, edges, node;
    cy = ev.cy;
    node = ev.cyTarget;
    edges = node.connectedEdges();
    return edges.forEach(function(edge) {
      var a, b, dist;
      a = node;
      b = edge.target();
      if (b === a) {
        b = node;
        a = edge.source();
      }
      dist = distance(a.position(), b.position());
      return edge.data("cost", dist);
    });
  };

  loadImage = function(src) {
    var def, img;
    def = $.Deferred();
    img = new Image();
    img.onload = function() {
      return def.resolve(img);
    };
    img.error = def.reject;
    img.src = src;
    return def.promise();
  };

  parsePixels = function(pixels) {
    var goThrough, i, idx, mask, val, _i;
    goThrough = [];
    idx = 0;
    for (i = _i = 1; _i <= 16; i = ++_i) {
      if (i % 8 === 0) {
        idx++;
      }
      mask = 1 << (i % 8);
      val = pixels[idx];
      if (val & mask) {
        goThrough.push(i);
      }
    }
    return goThrough;
  };

  unpackImageData = function(data) {
    var b, endAt, entries, g, goThrough, i, r, _i, _len, _step;
    entries = [];
    for (i = _i = 0, _len = data.length, _step = 4; _i < _len; i = _i += _step) {
      r = data[i];
      g = data[i + 1];
      b = data[i + 2];
      endAt = r;
      goThrough = parsePixels([g, b]);
      entries.push([endAt, goThrough]);
    }
    return entries;
  };

  unpackImage = function(img) {
    var canvas, ctx, data;
    canvas = $("#unpack-canvas")[0];
    canvas.width = img.width;
    canvas.height = img.height;
    ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, img.width, img.height);
    data = (ctx.getImageData(0, 0, img.width, img.height)).data;
    return unpackImageData(data);
  };

  loadSubpathLevels = function(nodeCount) {
    var i, promise, promises, src, _i;
    promises = [];
    for (i = _i = 0; 0 <= nodeCount ? _i < nodeCount : _i > nodeCount; i = 0 <= nodeCount ? ++_i : --_i) {
      src = "levels/" + nodeCount + "/" + i + ".png";
      promise = loadImage(src);
      promises.push(promise);
    }
    promise = $.when.apply($, promises);
    return promise.then(function() {
      var stuff;
      stuff = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return stuff;
    });
  };

  costMatrixFromNodes = function(nodes) {
    var cost, costs, i, j, size, _i, _j;
    size = _.size(nodes);
    costs = [];
    for (i = _i = 0; 0 <= size ? _i < size : _i > size; i = 0 <= size ? ++_i : --_i) {
      for (j = _j = 0; 0 <= size ? _j < size : _j > size; j = 0 <= size ? ++_j : --_j) {
        cost = nodes[i][j];
        if (_.isUndefined(cost)) {
          cost = 0;
        }
        costs.push(cost);
      }
    }
    return costs;
  };

  buildCPUSolver = function() {
    var levelGen;
    levelGen = function(nodes) {
      return async(function() {
        return generateLevels(nodes);
      });
    };
    levelGen = function(nodes) {
      var numNodes, promise;
      numNodes = _.size(nodes);
      promise = loadSubpathLevels(numNodes);
      return promise.then(function(images) {
        var levels;
        return levels = _.map(images, unpackImage);
      });
    };
    levelGen = _.memoize(levelGen, function(nodes) {
      return _.size(nodes);
    });
    return function(nodes) {
      var levelPromise;
      levelPromise = levelGen(nodes);
      return levelPromise.then(function(levels) {
        var elapsed, path, start;
        start = now();
        path = heldKarp(nodes, levels);
        elapsed = now() - start;
        return [path, elapsed];
      });
    };
  };

  hashPixel = function(pixel) {
    var b, b1, b2, b3, g, r;
    r = pixel[0], g = pixel[1], b = pixel[2];
    b1 = r << 16;
    b2 = g << 8;
    b3 = b;
    return b1 | b2 | b3;
  };

  packPixel = function(endAt, goThrough) {
    var agg, aggIdx, num, val, _i, _len;
    agg = [endAt, 0, 0];
    for (_i = 0, _len = goThrough.length; _i < _len; _i++) {
      num = goThrough[_i];
      aggIdx = Math.floor(num / 8) + 1;
      val = 1 << (num % 8);
      agg[aggIdx] |= val;
    }
    return agg;
  };

  textureLookupCost = function(arr, endAt, goThrough) {
    var cost, idx, parent, pixel;
    pixel = packPixel(endAt, goThrough);
    idx = hashPixel(pixel) * 4;
    cost = arr[idx];
    parent = arr[idx + 1];
    return [cost, parent];
  };

  backtrackParents = function(nodes, outputs) {
    var cost, endAt, goThrough, num, outIdx, parent, path, _i, _ref, _results;
    num = _.size(nodes);
    goThrough = (function() {
      _results = [];
      for (var _i = 1; 1 <= num ? _i < num : _i > num; 1 <= num ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    endAt = 0;
    outIdx = 1;
    path = [endAt];
    while (true) {
      _ref = textureLookupCost(outputs[outIdx], endAt, goThrough), cost = _ref[0], parent = _ref[1];
      goThrough = _.difference(goThrough, [parent]);
      endAt = parent;
      path.push(parent);
      outIdx = (outIdx + 1) % 2;
      if (parent === 0) {
        break;
      }
    }
    return path;
  };

  buildGPUSolver = function(engine, numNodes) {
    var comp, dummyData, dummyInputs, i, kernel, levelGen, levelPromise, output1, output2, outputs, preamble, size, startingMinCost, _ref;
    levelGen = function() {
      var promise, src;
      src = "levels/" + MAX_NODES + ".png";
      promise = loadImage(src);
      return promise.then(function(image) {
        var storage;
        storage = Storage.fromImage(engine, image, "UNSIGNED_BYTE");
        return storage.tex;
      });
    };
    size = [4096, 256];
    startingMinCost = 999999;
    dummyData = new Float32Array((function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = size[0] * size[1] * 4; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(startingMinCost);
      }
      return _results;
    })());
    dummyInputs = Storage.fromSize(engine, size, dummyData);
    output1 = Storage.fromSize(engine, size, dummyData);
    output2 = Storage.fromSize(engine, size, dummyData);
    outputs = [output1, output2];
    _ref = constructComputationKernels(numNodes), preamble = _ref[0], kernel = _ref[1];
    comp = engine.createComputation(size, kernel, preamble, 4);
    levelPromise = levelGen();
    return function(nodes, perf) {
      var num, uniforms;
      num = _.size(nodes);
      uniforms = {
        num_nodes: ["1i", num],
        level_tex_size: ["2fv", size],
        cost_matrix: ["1fv", costMatrixFromNodes(nodes)]
      };
      return levelPromise.then(function(levelTex) {
        var curOutput, elapsed, evenOutput, level, oddOutput, path, start, _i;
        uniforms.level_tex = ["s", levelTex];
        start = now();
        for (level = _i = 0; 0 <= num ? _i < num : _i > num; level = 0 <= num ? ++_i : --_i) {
          curOutput = outputs[0];
          uniforms.cur_level = ["1i", level];
          uniforms.subpath_tex = ["s", outputs[1]];
          comp.step(dummyInputs, uniforms, curOutput);
          outputs.reverse();
        }
        evenOutput = outputs[0].download();
        oddOutput = outputs[1].download();
        path = backtrackParents(nodes, [evenOutput, oddOutput]);
        elapsed = now() - start;
        return [path, elapsed];
      });
    };
  };

  failGPU = function(msg) {
    if (msg == null) {
      msg = "Unknown";
    }
    $("#gpu-fail").show();
    $("#gpu-fail-reason").html(msg);
    $("#gpu-solver-opt").attr("disabled", "disabled");
    return chartPromise.then(function(chart) {
      var data, idx, _i, _results;
      data = chart.getDataTable();
      _results = [];
      for (idx = _i = MIN_NODES; MIN_NODES <= MAX_NODES ? _i <= MAX_NODES : _i >= MAX_NODES; idx = MIN_NODES <= MAX_NODES ? ++_i : --_i) {
        _results.push(data.setValue(idx - 3, 2, 100));
      }
      return _results;
    });
  };

  root = $("#gpgpu");

  engine = null;

  try {
    engine = getEngine(root);
  } catch (error) {
    failGPU(error);
  }

  cpuSolver = buildCPUSolver();

  gpuSolver = null;

  if (engine) {
    gpuSolver = buildGPUSolver(engine, DEFAULT_NUM_NODES);
  }

  getSolverType = function() {
    return $("#selected-solver option:checked").val();
  };

  getSolver = function() {
    if (getSolverType() === "cpu") {
      return cpuSolver;
    } else {
      return gpuSolver;
    }
  };

  this.cy = cytoscape({
    container: $("#cy"),
    userZoomingEnabled: false,
    userPanningEnabled: false,
    boxSelectionEnabled: false,
    style: [
      {
        selector: "node",
        style: {
          content: "data(id)",
          "text-valign": "center",
          "color": "white",
          "text-outline-width": 2,
          "background-color": "#999",
          "text-outline-color": "#999"
        }
      }, {
        selector: "edge.route",
        style: {
          width: 1.5,
          "line-color": "#000",
          opacity: 0.1,
          "z-index": 10
        }
      }, {
        selector: "node.tour",
        style: {
          "background-color": TOUR_COLOR,
          "text-outline-color": TOUR_COLOR
        }
      }, {
        selector: "edge.tour",
        style: {
          "width": "4px",
          opacity: 1,
          "line-color": TOUR_COLOR,
          "curve-style": "haystack",
          "mid-target-arrow-color": TOUR_COLOR,
          "z-index": 20
        }
      }, {
        selector: ".autorotate",
        style: {
          "edge-text-rotation": "autorotate"
        }
      }
    ]
  });

  updateGraph = function(cy, nodes) {
    return graphNodes(cy, getSolver(), nodes, true);
  };

  clearGraph = function(cy) {
    return cy.elements().remove();
  };

  resetGraph = function(cy, numNodes) {
    var nodes;
    if (numNodes == null) {
      numNodes = null;
    }
    if (numNodes === null) {
      numNodes = getNumNodes(cy);
    }
    clearGraph(cy);
    nodes = generateNodes(numNodes);
    return updateGraph(cy, nodes);
  };

  refreshNodes = function(cy, nodes) {
    if (engine && getSolverType() === "gpu") {
      gpuSolver = buildGPUSolver(engine, _.size(nodes));
    }
    clearGraph(cy);
    return updateGraph(cy, nodes);
  };

  addNode = function(cy) {
    var nodes;
    nodes = extractNodesForAugment(cy);
    pushNode(nodes);
    return refreshNodes(cy, nodes);
  };

  removeNode = function(cy) {
    var nodes;
    nodes = extractNodesForAugment(cy);
    popNode(nodes);
    return refreshNodes(cy, nodes);
  };

  drawChart = function() {
    var data, i, opts, _i, _results;
    data = new google.visualization.DataTable();
    data.addColumn("number", "X");
    data.addColumn("number", "CPU");
    data.addColumn("number", "GPU");
    data.addRows((function() {
      var _i, _results;
      _results = [];
      for (i = _i = MIN_NODES; MIN_NODES <= MAX_NODES ? _i <= MAX_NODES : _i >= MAX_NODES; i = MIN_NODES <= MAX_NODES ? ++_i : --_i) {
        _results.push([i, null, null]);
      }
      return _results;
    })());
    opts = {
      chartType: "LineChart",
      containerId: "tsp-perf-chart",
      dataTable: data,
      options: {
        title: "Logarithmic Performance",
        curveType: "function",
        legend: {
          position: "right"
        },
        hAxis: {
          title: "Number of nodes",
          ticks: (function() {
            _results = [];
            for (var _i = MIN_NODES; MIN_NODES <= MAX_NODES ? _i <= MAX_NODES : _i >= MAX_NODES; MIN_NODES <= MAX_NODES ? _i++ : _i--){ _results.push(_i); }
            return _results;
          }).apply(this)
        },
        vAxis: {
          title: "Time (ms)",
          logScale: true
        }
      }
    };
    chart = new google.visualization.ChartWrapper(opts);
    chart._performanceAggs = (function() {
      var _j, _results1;
      _results1 = [];
      for (i = _j = MIN_NODES; MIN_NODES <= MAX_NODES ? _j <= MAX_NODES : _j >= MAX_NODES; i = MIN_NODES <= MAX_NODES ? ++_j : --_j) {
        _results1.push([[], []]);
      }
      return _results1;
    })();
    chart.draw();
    return chartDef.resolve(chart);
  };

  google.charts.load("current", {
    packages: ["corechart"]
  });

  google.charts.setOnLoadCallback(drawChart);

  chartPromise.then(function() {
    return resetGraph(cy, DEFAULT_NUM_NODES);
  });

  updateUICost = function(cost) {
    return $("#tour-cost").text(_.round(cost, 2));
  };

  updateUITime = function(elapsed, nodes, solver) {
    return chartPromise.then(function(chart) {
      var data, idx, meanElapsed, numNodes, old, solverIdx;
      numNodes = _.size(nodes);
      idx = numNodes - 3;
      solverIdx = getSolverType() === "cpu" ? 1 : 2;
      data = chart.getDataTable();
      old = chart._performanceAggs[idx][solverIdx - 1];
      if (old.length >= MAX_PERFORMANCE_POINTS) {
        old.shift();
      }
      old.push(elapsed);
      meanElapsed = _.mean(old);
      data.setValue(idx, solverIdx, meanElapsed);
      chart.draw();
      return $("#tour-time").text(_.round(elapsed));
    });
  };

  cy.on("free", function(ev) {
    cy.edges().removeClass("tour");
    cy.nodes().removeClass("tour");
    updateCost(ev);
    return recomputeTSP(cy, getSolver());
  });

  $("#selected-solver").change(function() {
    var nodes;
    nodes = extractNodesForAugment(cy);
    return refreshNodes(cy, nodes);
  });

  $("#randomize-graph").click(function() {
    return resetGraph(cy);
  });

  $("#add-node").click(function(ev) {
    var num;
    addNode(cy);
    num = getNumNodes(cy);
    $("#remove-node").prop("disabled", false);
    if (num >= MAX_NODES) {
      return $(ev.target).prop("disabled", true);
    }
  });

  $("#remove-node").click(function(ev) {
    var num;
    removeNode(cy);
    num = getNumNodes(cy);
    $("#add-node").prop("disabled", false);
    if (num <= MIN_NODES) {
      return $(ev.target).prop("disabled", true);
    }
  });

  $(".math").each(function(i, el) {
    return katex.render($(el).text(), el);
  });

  $(function() {
    return $("pre code").each(function(i, block) {
      return hljs.highlightBlock(block);
    });
  });

}).call(this);
