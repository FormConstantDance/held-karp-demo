// Generated by CoffeeScript 1.4.0
(function() {
  var assert, backTrackParents, combinations, combinations2, createKey, createNode, findCost, powerset, product, runTests, testCombinations, testProduct;

  assert = function(condition, message) {
    if (!condition) {
      throw message || "Assertion failed";
    }
  };

  product = function(a, b, combine) {
    var res;
    if (combine == null) {
      combine = function(elA, elB) {
        return [elA, elB];
      };
    }
    res = [];
    _.each(a, function(elA) {
      return _.each(b, function(elB) {
        return res.push(combine(elA, elB));
      });
    });
    return res;
  };

  combinations = function(elements, k) {
    var canMove, capture, endTest, lastIdx, lastPtrIdx, pIdx, pointers, resetPointers, results, _i, _results;
    if (k === 0) {
      return [[]];
    }
    lastIdx = elements.length - 1;
    pointers = (function() {
      _results = [];
      for (var _i = 0; 0 <= k ? _i < k : _i > k; 0 <= k ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    endTest = lastIdx - k;
    lastPtrIdx = pointers.length - 1;
    resetPointers = function(pIdx) {
      var prevIdx;
      prevIdx = pointers[pIdx];
      pIdx++;
      return _.each(_.slice(pointers, pIdx), function() {
        var newIdx;
        newIdx = prevIdx + 1;
        pointers[pIdx] = newIdx;
        prevIdx = newIdx;
        return pIdx++;
      });
    };
    capture = function() {
      return _.map(pointers, function(idx) {
        return elements[idx];
      });
    };
    canMove = function(pIdx, pointers) {
      var maxAllowedIdx, val;
      val = pointers[pIdx];
      maxAllowedIdx = elements.length - k + pIdx;
      return val + 1 <= maxAllowedIdx;
    };
    pIdx = lastPtrIdx;
    results = [];
    results.push(capture());
    while (true) {
      if (canMove(pIdx, pointers)) {
        pointers[pIdx] += 1;
        if (pIdx < lastPtrIdx) {
          resetPointers(pIdx);
          pIdx = lastPtrIdx;
        }
        results.push(capture());
      } else if (pIdx === 0) {
        break;
      } else {
        pIdx--;
      }
    }
    return results;
  };

  combinations2 = function(elements, k) {
    var combos, el, first, slice, sub1, sub2;
    if (k > elements.length) {
      combos = [];
    } else if (k === 1) {
      combos = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = elements.length; _i < _len; _i++) {
          el = elements[_i];
          _results.push([el]);
        }
        return _results;
      })();
    } else {
      first = elements[0];
      slice = _.slice(elements, 1);
      sub1 = combinations2(slice, k - 1);
      sub1 = product([first], sub1, _.concat);
      sub2 = combinations2(slice, k);
      combos = _.concat(sub1, sub2);
    }
    return combos;
  };

  powerset = function(elements) {
    var fn, _i, _ref, _results;
    fn = _.partial(combinations, elements);
    return _.map((function() {
      _results = [];
      for (var _i = 0, _ref = elements.length; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this), fn);
  };

  testCombinations = function() {
    var correct, results;
    results = combinations(["a", "b", "c", "d", "e"], 2);
    correct = [["a", "b"], ["a", "c"], ["a", "d"], ["a", "e"], ["b", "c"], ["b", "d"], ["b", "e"], ["c", "d"], ["c", "e"], ["d", "e"]];
    assert(_.isEqual(results, correct));
    results = combinations(["a", "b", "c", "d", "e"], 4);
    correct = [["a", "b", "c", "d"], ["a", "b", "c", "e"], ["a", "b", "d", "e"], ["a", "c", "d", "e"], ["b", "c", "d", "e"]];
    assert(_.isEqual(results, correct));
    results = combinations(["a", "b", "c", "d", "e"], 5);
    correct = [["a", "b", "c", "d", "e"]];
    assert(_.isEqual(results, correct));
    results = combinations(["a", "b", "c", "d", "e"], 1);
    correct = [["a"], ["b"], ["c"], ["d"], ["e"]];
    assert(_.isEqual(results, correct));
    results = combinations(["a", "b", "c"], 0);
    correct = [[]];
    assert(_.isEqual(results, correct));
    results = combinations([1, 2, 3, 4, 5], 3);
    correct = [[1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5], [1, 4, 5], [2, 3, 4], [2, 3, 5], [2, 4, 5], [3, 4, 5]];
    return assert(_.isEqual(results, correct));
  };

  testProduct = function() {
    var correct, results;
    results = product([], []);
    correct = [];
    assert(_.isEqual(results, correct));
    results = product(["a", "b"], ["c"]);
    correct = [["a", "c"], ["b", "c"]];
    assert(_.isEqual(results, correct));
    results = product(["c"], ["a", "b"]);
    correct = [["c", "a"], ["c", "b"]];
    assert(_.isEqual(results, correct));
    results = product([], ["a", "b"]);
    correct = [];
    return assert(_.isEqual(results, correct));
  };

  runTests = function() {
    testCombinations();
    return testProduct();
  };

  this.generateLevels = function(nodes) {
    var allLevels, endAt, family, goThrough, level, levels, nodesMinusStart, subset, _i, _j, _len, _len1;
    nodesMinusStart = _.without(_.map(_.keys(nodes), _.toInteger), 0);
    family = powerset(nodesMinusStart);
    allLevels = [];
    for (_i = 0, _len = family.length; _i < _len; _i++) {
      subset = family[_i];
      levels = [];
      for (_j = 0, _len1 = subset.length; _j < _len1; _j++) {
        goThrough = subset[_j];
        endAt = _.difference(nodesMinusStart, goThrough);
        if (_.isEmpty(endAt)) {
          endAt = [0];
        }
        level = product(endAt, [goThrough]);
        levels = _.concat(levels, level);
      }
      allLevels.push(levels);
    }
    return allLevels;
  };

  createKey = function(list) {
    return _.join(list, ",");
  };

  findCost = function(endAt, goThrough, cache, nodes) {
    var bestCost, bestParent, combo, combos, key, potentialParent, subCost, subParent, totalCost, _i, _len, _ref;
    bestCost = Infinity;
    bestParent = null;
    if (_.isEqual(goThrough, [])) {
      bestParent = 0;
      bestCost = nodes[0][endAt];
    } else {
      combos = combinations(goThrough, goThrough.length - 1);
      for (_i = 0, _len = combos.length; _i < _len; _i++) {
        combo = combos[_i];
        potentialParent = (_.difference(goThrough, combo))[0];
        key = createKey(_.concat(potentialParent, combo));
        _ref = cache[key], subCost = _ref[0], subParent = _ref[1];
        totalCost = subCost + nodes[potentialParent][endAt];
        if (totalCost < bestCost) {
          bestCost = totalCost;
          bestParent = potentialParent;
        }
      }
    }
    return [bestCost, bestParent];
  };

  backTrackParents = function(cache, levels, endParent) {
    var key, lastLevel, path, subPath;
    path = [endParent];
    lastLevel = _.last(levels);
    subPath = lastLevel[0][1];
    while (!_.isEmpty(subPath)) {
      subPath = _.difference(subPath, [endParent]);
      key = createKey(_.concat(endParent, subPath));
      endParent = cache[key][1];
      path.push(endParent);
    }
    return path;
  };

  this.heldKarp = function(nodes, levels) {
    var cache, cost, endAt, goThrough, key, level, levelNum, parent, path, subset, _i, _j, _len, _len1, _ref;
    cache = {};
    for (levelNum = _i = 0, _len = levels.length; _i < _len; levelNum = ++_i) {
      level = levels[levelNum];
      for (_j = 0, _len1 = level.length; _j < _len1; _j++) {
        subset = level[_j];
        endAt = subset[0], goThrough = subset[1];
        _ref = findCost(endAt, goThrough, cache, nodes), cost = _ref[0], parent = _ref[1];
        key = createKey(_.concat(endAt, goThrough));
        cache[key] = [cost, parent];
      }
    }
    path = backTrackParents(cache, levels, parent);
    path.reverse();
    path.push(0);
    return path;
  };

  this.generateTour = function(num, maxEdgeCost) {
    var cost, edge, edges, getCost, node, nodes, _i, _j;
    if (maxEdgeCost == null) {
      maxEdgeCost = 100;
    }
    nodes = {};
    getCost = function() {
      return _.toInteger(Math.random() * maxEdgeCost);
    };
    for (node = _i = 0; 0 <= num ? _i < num : _i > num; node = 0 <= num ? ++_i : --_i) {
      edges = {};
      nodes[node] = edges;
      for (edge = _j = 0; 0 <= num ? _j < num : _j > num; edge = 0 <= num ? ++_j : --_j) {
        cost = getCost();
        edges[edge] = cost;
      }
    }
    return nodes;
  };

  this.distance = function(a, b) {
    var x, y;
    x = b.x - a.x;
    y = b.y - a.y;
    return Math.sqrt(x * x + y * y);
  };

  createNode = function(id) {
    var node, x, y;
    x = Math.random();
    y = Math.random();
    return node = {
      id: id,
      pos: {
        x: x,
        y: y
      }
    };
  };

  this.computeEdges = function(nodes) {
    var d, i, key, n1, n2, _results;
    _results = [];
    for (key in nodes) {
      n1 = nodes[key];
      n1.edges = {};
      _results.push((function() {
        var _results1;
        _results1 = [];
        for (i in nodes) {
          n2 = nodes[i];
          d = distance(n1.pos, n2.pos);
          _results1.push(n1.edges[i] = d);
        }
        return _results1;
      })());
    }
    return _results;
  };

  this.pushNode = function(nodes) {
    var id;
    id = _.size(nodes);
    nodes[id] = createNode(id);
    return this.computeEdges(nodes);
  };

  this.popNode = function(nodes) {
    var id;
    id = (_.size(nodes)) - 1;
    delete nodes[id];
    return this.computeEdges(nodes);
  };

  this.generateNodes = function(num, asymmetric) {
    var i, nodes, _i;
    if (asymmetric == null) {
      asymmetric = false;
    }
    nodes = {};
    for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
      nodes[i] = createNode(i);
    }
    this.computeEdges(nodes);
    return nodes;
  };

}).call(this);
